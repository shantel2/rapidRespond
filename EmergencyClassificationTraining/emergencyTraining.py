# -*- coding: utf-8 -*-
"""EmergencyPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SjEKIaTTUb-28C-rVzyrqgs5zcTjDaRR
"""

import pandas as pd

# Read the text file
df = pd.read_csv('train.txt', sep='%', header=None, names=['emergency_text', 'emergency_type'])

# Save the DataFrame to a CSV file
df.to_csv('output.csv', index=False)

categories = ["Fire", "Police","Medical"]

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import classification_report
import joblib

# Load the dataset
data = pd.read_csv('output.csv')

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(data['emergency_text'], data['emergency_type'], test_size=0.2)

# Vectorize the data
vectorizer = CountVectorizer()
X_train = vectorizer.fit_transform(X_train)
X_test = vectorizer.transform(X_test)

# Train the Naive Bayes model
clf1 = MultinomialNB()
clf1.fit(X_train, y_train)

# Evaluate the model
y_pred = clf1.predict(X_test)
print(classification_report(y_test, y_pred))

# Export the vectorizer and model using joblib
joblib.dump(vectorizer, 'vectorizer.joblib')
joblib.dump(clf1, 'nb_model.joblib')

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.svm import SVC
from sklearn.metrics import classification_report
import joblib

# Load the dataset
data = pd.read_csv('output.csv')
X_train, X_test, y_train, y_test = 0,0,0,0
# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(data['emergency_text'], data['emergency_type'], test_size=0.2)

# Vectorize the data
vectorizer2 = CountVectorizer()
X_train = vectorizer2.fit_transform(X_train)
X_test = vectorizer2.transform(X_test)

# Train the SVM model
clf2 = SVC(kernel='linear')
clf2.fit(X_train, y_train)

# Evaluate the model
y_pred = clf2.predict(X_test)
print(classification_report(y_test, y_pred))

# Export the model using joblib
joblib.dump(clf2, 'svm_model.joblib')
joblib.dump(vectorizer2, 'vectorizer2.joblib')

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import classification_report
import joblib

# Load the dataset
data = pd.read_csv('output.csv')
X_train, X_test, y_train, y_test = 0,0,0,0
# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(data['emergency_text'], data['emergency_type'], test_size=0.2,random_state=7)

# Vectorize the data
vectorizer3 = CountVectorizer()
X_train = vectorizer3.fit_transform(X_train)
X_test = vectorizer3.transform(X_test)

# Train the Gradient Boosting model
clf3 = GradientBoostingClassifier()
clf3.fit(X_train, y_train)

# Evaluate the model
y_pred = clf3.predict(X_test)
print(classification_report(y_test, y_pred))

# Export the model using joblib
joblib.dump(clf3, 'gradient_boosting_model.joblib')
joblib.dump(vectorizer3, 'vectorizer3.joblib')

import joblib
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer

# Load the model and vectorizer
clf2 = joblib.load('svm_model.joblib')
vectorizer2 = joblib.load("vectorizer2.joblib") #loads vectoriser

# Get user input
input_text = "There's a mad man walking around with a gun"
# Vectorize the input text
input_vector = vectorizer2.transform([input_text])

# Make prediction
prediction = clf2.predict(input_vector)

# Print result
print(categories[prediction[0]])

import joblib
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer

# Load the model and vectorizer
clf3 = joblib.load('gradient_boosting_model.joblib')
vectorizer3 = joblib.load("vectorizer3.joblib") #loads vectoriser

# Get user input
input_text = "There's a mad man walking around with a gun"
# Vectorize the input text
input_vector = vectorizer3.transform([input_text])

# Make prediction
prediction = clf3.predict(input_vector)

# Print result
print(categories[prediction[0]])

import joblib
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer


categories = ['Fire', 'Police', 'Medical']
def makePrediction(text):
  #Load in models
  clf1 = joblib.load('nb_model.joblib')
  vectorizer1 = joblib.load("vectorizer.joblib")
  clf2 = joblib.load('svm_model.joblib')
  vectorizer2 = joblib.load("vectorizer2.joblib")
  clf3 = joblib.load('gradient_boosting_model.joblib')
  vectorizer3 = joblib.load("vectorizer3.joblib") 
  #Make Prediction - Naive Bayes
  input_vector = vectorizer1.transform([text])
  prediction = clf1.predict(input_vector)
  outcome1 = categories[prediction[0]]

  #Make Prediction - SVM
  input_vector = vectorizer2.transform([text])
  prediction = clf2.predict(input_vector)
  outcome2 = categories[prediction[0]]

  #Make Prediction - Gradient Boosting
  input_vector = vectorizer3.transform([text])
  prediction = clf3.predict(input_vector)
  outcome3 = categories[prediction[0]]

  #Concensus Prediction Return
  if outcome1==outcome2==outcome3:
    return outcome1
  if outcome1 != outcome2 and outcome1 != outcome3 and outcome2 != outcome3:
    return outcome3
  if outcome1 == outcome2:
    return outcome1
  if outcome1 == outcome3:
    return outcome1
  else:
    return outcome2

print(makePrediction("I,m dying, I think I'm bleeding out to death"))

!zip -r /content/ForAbby_Last_Last.zip /content/