# -*- coding: utf-8 -*-
"""Location Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vo4_DjGTLc00YkpOZgoDuextrpITEYa5

Credits to swapnil-saxena for providing inspiration and guidance for the creation of this model along the day
"""

https://github.com/swapnil-saxena/address-parser

"""Intialize the osmium and spacy modules through importation"""

!pip install osmium

import spacy
from spacy.tokens import DocBin

"""Read in sentences to to input addresses"""

# Import the csv module
import csv

# Create an empty list to hold the queries
queries = []

# Open the file 'queries.txt' in read mode with encoding set to UTF-8
with open('queries.txt', 'r', encoding='utf-8') as infile:

    # Use the csv.reader() function to read the file
    read = csv.reader(infile)

    # Loop through each row in the file
    for row in read:
        # Get the first item in the row
        currRow = row[0]
        
        # Replace any occurrences of '[Address]' with '[address]'
        if "[Address]" in currRow:
            currRow = currRow.replace('[Address]', '[address]')
        
        # Remove any trailing period from the query
        if currRow[-1] == '.':
            currRow = currRow[:-1]
        
        # Append the modified query to the list of queries
        queries.append(currRow)

"""Parsing input text in order to get the span to train the spaCy model"""

# Import the pandas module
import pandas as pd

# Import the re module for regular expressions
import re

# Define a function called 'get_address_span' that takes three arguments
def get_address_span(address=None, address_component=None, label=None):

    # Check if the 'address_component' argument is None or NaN
    if pd.isna(address_component) or str(address_component) == 'nan':
        # If it is, do nothing and exit the function
        pass
    else:
        # If it's not None or NaN, use the re module to find the position of the 'address_component' in the 'address' string
        for match in re.finditer(rf"\b{re.escape(address_component)}\b", address):
            # Get the start and end positions of the match
            start = match.start()
            end = match.end()

            # If the end position is less than the length of the address and the character at that position is a period, increment the end position
            if end < len(address) and address[end] == ".":
                end += 1
            
            # Return a tuple containing the start position, end position, and label

            return (start, end, label)

"""Creating the spaCy config file from the base_config file created online"""

!python -m spacy init fill-config base_config.cfg config.cfg

"""Trains with data in the comma format like street, city, country."""

# Import required modules
import osmium
import csv
import random

# Function to replace the '[address]' placeholder in a sentence with the actual address
def replace_address(sentence, address):
    return sentence.replace('[address]', address)

queryTracker = 0
# Class that extends the osmium.SimpleHandler class to extract address information from OSM nodes
class AddressHandler(osmium.SimpleHandler):
    
    # Initialize the AddressHandler instance
    def __init__(self):
        # Call the __init__ method of the osmium.SimpleHandler class
        osmium.SimpleHandler.__init__(self)
        
        # Create a list to store the query and address data
        self.addresses = [['query','address']]
        
        # Initialize a count variable to keep track of the number of nodes processed
        self.count = 0

    # Method that is called for each node in the OSM data
    def node(self, n):
        global queryTracker
        # Get the tags associated with the node
        tags = n.tags
        
        # Initialize variables to store the address components
        housenumber, street, city, postcode, highway, amenity, shop, building  = "","","","","","","",""
        
        # Extract the address components from the tags, if they exist
        if 'addr:housenumber' in tags:
          housenumber = tags['addr:housenumber']
          
        if 'addr:street' in tags:
          street = tags['addr:street']
          
        if 'addr:city' in tags:
          city = tags.get('addr:city', '')
          
        if 'addr:postcode' in tags:
          postcode = tags.get('addr:postcode', '')
          
        # Construct the query address string from the address components
        queryAddress = ""
        if housenumber != "" or  street != "" or city != "" or postcode!= "":
          if housenumber!= "":
            queryAddress += housenumber+", "
          if street!= "":
            queryAddress += street+", "
          if city != "":
            queryAddress += city+", "
          if postcode!= "":
            queryAddress += postcode+", "
            
          # Remove the trailing comma and space from the query address string
          queryAddress = queryAddress.strip(", ")
          
          # Select a random query sentence and replace the '[address]' placeholder with the actual address
          query = replace_address(queries[queryTracker%len(queries)], queryAddress)
          queryTracker+=1
          # Add the query and address data to the addresses list (both the original and lowercase versions)
          self.addresses.append([query, queryAddress])
          self.addresses.append([query.lower(), queryAddress.lower()])

          
        

# Create an AddressHandler object
handler = AddressHandler()

# Apply the handler to the PBF file
handler.apply_file("jamaica-latest.osm.pbf")

# Access the address data
addresses = handler.addresses


# Class that extends the osmium.SimpleHandler class to extract highway information from OSM ways
class HighwayHandler(osmium.SimpleHandler):
    
    # Initialize the HighwayHandler instance
    def __init__(self):
        # Call the __init__ method of the osmium.SimpleHandler class
        super(HighwayHandler, self).__init__()
        
        # Create a list to store the highway name and query data
        self.highways = []
    
    # Method that is called for each way in the OSM data
    def way(self, w):
        global queryTracker
        # Initialize variables to store the address components
        housenumber, street, city, postcode, highway, amenity, shop, building  = "","","","","JM","","",""
        
        # Extract the highway tag from the way, if it exists
        if 'highway' in w.tags:
            highway = {}
            highway['name'] = w.tags.get('name', '')
            
            # If a name is specified for the highway, create a query string and add it to the highways list (both the original and lowercase versions)
            if highway['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], highway['name'])
              queryTracker+=1
              self.highways.append([query,highway['name']])
              self.highways.append([query.lower(),highway['name'].lower()])


# create an instance of the handler and apply it to the .pbf file
handler = HighwayHandler()
handler.apply_file('jamaica-latest.osm.pbf')
highways = handler.highways
class AmenityHandler(osmium.SimpleHandler):
    def __init__(self):
        super(AmenityHandler, self).__init__()
        self.amenities = []
    
    def node(self, n):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'amenity' in n.tags:
            amenity = {}
            amenity['name'] = n.tags.get('name', '') 
            if amenity['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], amenity['name'])
              queryTracker+=1
              self.amenities.append([query,amenity['name']])
              self.amenities.append([query.lower(),amenity['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = AmenityHandler()
handler.apply_file('jamaica-latest.osm.pbf')
amenities = handler.amenities

class ShopHandler(osmium.SimpleHandler):
    def __init__(self):
        super(ShopHandler, self).__init__()
        self.shops = []
    
    def node(self, n):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'shop' in n.tags:
            shop = {}
            shop['name'] = n.tags.get('name', '')
            if shop['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], shop['name'])
              queryTracker+=1
              self.shops.append([query, shop['name']])
              self.shops.append([query.lower(), shop['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = ShopHandler()
handler.apply_file('jamaica-latest.osm.pbf')
shops = handler.shops

class BuildingHandler(osmium.SimpleHandler):
    def __init__(self):
        super(BuildingHandler, self).__init__()
        self.buildings = []
    
    def way(self, w):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'building' in w.tags:
            building = {}
            building['name'] = w.tags.get('name', '')
            if building['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], building['name'])
              queryTracker+=1
              self.buildings.append([query,building['name']])
              self.buildings.append([query.lower(),building['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = BuildingHandler()
handler.apply_file('jamaica-latest.osm.pbf')
buildings = handler.buildings

# open a new file for writing
with open('addresses.csv', 'w', encoding='utf-8') as f:
    writer = csv.writer(f)
    # write the data to the file
    for row in addresses:
        writer.writerow(row)
with open('addresses.csv', 'a', encoding='utf-8') as f:
    # create a writer object and specify the fieldnames
    writer = csv.writer(f)
    
    # write the data to the file
    for row in highways:
        writer.writerow(row)

with open('addresses.csv', 'a', encoding='utf-8') as f:
    writer = csv.writer(f)
    
    
    # write the data to the file
    for row in amenities:
        writer.writerow(row)

with open('addresses.csv', 'a', encoding='utf-8') as f:
    writer = csv.writer(f)
    # write the data to the file
    for row in shops:
        writer.writerow(row)
with open('addresses.csv', 'a', encoding='utf-8') as f:
   
    writer = csv.writer(f)
    # write the data to the file
    for row in buildings:
        writer.writerow(row)

"""Trains with data in a format that does not use commas like street city country"""

import osmium
import csv
import random


def replace_address(sentence, address):
    return sentence.replace('[address]', address)


queryTracker = 0


class AddressHandler(osmium.SimpleHandler):
    def __init__(self):
        osmium.SimpleHandler.__init__(self)
        self.addresses = []
        self.count = 0

    def node(self, n):
        global queryTracker
        tags = n.tags
        housenumber, street, city, postcode, highway, amenity, shop, building  = "","","","","","","",""
        
        if 'addr:housenumber' in tags:
          housenumber = tags['addr:housenumber']
          
        if 'addr:street' in tags:
          street = tags['addr:street']
          
        if 'addr:city' in tags:
          city = tags.get('addr:city', '')
          
        if 'addr:postcode' in tags:
          postcode = tags.get('addr:postcode', '')
          
          
        queryAddress = ""
        if housenumber != "" or  street != "" or city != "" or postcode!= "":
          if housenumber!= "":
            queryAddress += housenumber+" "
          if street!= "":
            queryAddress += street+" "
          if city != "":
            queryAddress += city+" "
          if postcode!= "":
            queryAddress += postcode+" "

          queryAddress = queryAddress.strip(" ")
          query = replace_address(queries[queryTracker%len(queries)], queryAddress)
          queryTracker+=1
          self.addresses.append([query, queryAddress])
          self.addresses.append([query.lower(), queryAddress.lower()])
          
        

# Create an AddressHandler object
handler = AddressHandler()

# Apply the handler to the PBF file
handler.apply_file("jamaica-latest.osm.pbf")

# Access the address data
addresses = handler.addresses


class HighwayHandler(osmium.SimpleHandler):
    def __init__(self):
        super(HighwayHandler, self).__init__()
        self.highways = []
    
    def way(self, w):
        global queryTracker
        housenumber, street, city, postcode, highway, amenity, shop, building  = "","","","","JM","","",""
        if 'highway' in w.tags:
            highway = {}
            highway['name'] = w.tags.get('name', '')
            if highway['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], highway['name'])
              queryTracker+=1
              self.highways.append([query,highway['name']])
              self.highways.append([query.lower(),highway['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = HighwayHandler()
handler.apply_file('jamaica-latest.osm.pbf')
highways = handler.highways
class AmenityHandler(osmium.SimpleHandler):
    def __init__(self):
        super(AmenityHandler, self).__init__()
        self.amenities = []
    
    def node(self, n):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'amenity' in n.tags:
            amenity = {}
            amenity['name'] = n.tags.get('name', '') 
            if amenity['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], amenity['name'])
              queryTracker+=1
              self.amenities.append([query.lower(),amenity['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = AmenityHandler()
handler.apply_file('jamaica-latest.osm.pbf')
amenities = handler.amenities

class ShopHandler(osmium.SimpleHandler):
    def __init__(self):
        super(ShopHandler, self).__init__()
        self.shops = []
    
    def node(self, n):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'shop' in n.tags:
            shop = {}
            shop['name'] = n.tags.get('name', '')
            if shop['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], shop['name'])
              queryTracker+=1
              self.shops.append([query.lower(), shop['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = ShopHandler()
handler.apply_file('jamaica-latest.osm.pbf')
shops = handler.shops

class BuildingHandler(osmium.SimpleHandler):
    def __init__(self):
        super(BuildingHandler, self).__init__()
        self.buildings = []
    
    def way(self, w):
        global queryTracker
        housenumber, street, city, postcode,highway, amenity, shop, building  = "","","","","","","",""
        if 'building' in w.tags:
            building = {}
            building['name'] = w.tags.get('name', '')
            if building['name'] != "":
              query = replace_address(queries[queryTracker%len(queries)], building['name'])
              queryTracker+=1 
              self.buildings.append([query.lower(),building['name'].lower()])

# create an instance of the handler and apply it to the .pbf file
handler = BuildingHandler()
handler.apply_file('jamaica-latest.osm.pbf')
buildings = handler.buildings

# open a new file for writing
with open('addresses.csv', 'a', encoding='utf-8') as f:
    writer = csv.writer(f)
    # write the data to the file
    for row in addresses:
        writer.writerow(row)
with open('addresses.csv', 'a', encoding='utf-8') as f:
    # create a writer object and specify the fieldnames
    writer = csv.writer(f)
    
    # write the data to the file
    for row in highways:
        writer.writerow(row)

with open('addresses.csv', 'a', encoding='utf-8') as f:
    writer = csv.writer(f)
    
    
    # write the data to the file
    for row in amenities:
        writer.writerow(row)

with open('addresses.csv', 'a', encoding='utf-8') as f:
    writer = csv.writer(f)
    # write the data to the file
    for row in shops:
        writer.writerow(row)
with open('addresses.csv', 'a', encoding='utf-8') as f:
   
    writer = csv.writer(f)
    # write the data to the file
    for row in buildings:
        writer.writerow(row)

"""Reading the training data in pandas, randomly shuffling it and selecting a test size of 20 percent and a training size of 80."""

import pandas as pd
from sklearn.model_selection import train_test_split

# Load addresses csv file into a DataFrame
df = pd.read_csv('addresses.csv')


# Shuffle the rows of the DataFrame
df = df.sample(frac=1, random_state=0)

# Split the DataFrame into training and test sets (80% training, 20% test)
train_df, test_df = train_test_split(df, test_size=0.2, random_state=0)

# Save the training and test sets to separate CSV files
train_df.to_csv('train.csv', index=False)

test_df.to_csv('test.csv', index=False)

"""Using lamda to label the entity span for each row in dataset"""

from spacy.util import filter_spans



def extend_list(entity_list,entity):
    if pd.isna(entity):
        return entity_list
    else:
        entity_list.append(entity)
        return entity_list

def create_entity_spans(df,tag_list):
    '''Create entity spans for training/test datasets'''
    #df['query']=df['query'].apply(lambda x: massage_data(x)) 
    df["AddressTag"]=df.apply(lambda row:get_address_span(address=row['query'],address_component=row['address'],label='ADDRESS'),axis=1)
    df['EmptySpan']=df.apply(lambda x: [], axis=1)

    
    for i in tag_list:
        df['EntitySpans']=df.apply(lambda row: extend_list(row['EmptySpan'],row[i]),axis=1)
        df['EntitySpans']=df[['EntitySpans','query']].apply(lambda x: (x[1], x[0]),axis=1)
    return df['EntitySpans']


def get_doc_bin(training_data,nlp):
    '''Create DocBin object for building training/test corpus'''
    # the DocBin will store the example documents
    db = DocBin()
    pass2 = False
    for text, annotations in training_data:
        doc = nlp(text) #Construct a Doc object
        ents = []
        for start, end, label in annotations:
            span = doc.char_span(start, end, label=label)
            if span == None:
              
              pass2 = True
            ents.append(span)
        if pass2 == True:
          pass2=False
          continue
        ents = filter_spans(ents)
        doc.ents = ents
        db.add(doc)
    return db



#Load blank English model. This is needed for initializing a Document object for our training/test set.
nlp = spacy.blank("en")






#Define custom entity tag list
tag_list=["AddressTag"]

df_train=pd.read_csv(filepath_or_buffer="train.csv",sep=",",dtype=str)


df_entity_spans= create_entity_spans(df_train.astype(str),tag_list)

training_data= df_entity_spans.values.tolist()




# Get & Persist DocBin to disk
doc_bin_train= get_doc_bin(training_data,nlp)
doc_bin_train.to_disk("train.spacy")

"""Create the test set for the model to validate on"""

###### Validation dataset prep ###########
# Read the validation dataset into pandas
df_test=pd.read_csv(filepath_or_buffer="test.csv",sep=",",dtype=str)

# Get entity spans
df_entity_spans= create_entity_spans(df_test.astype(str),tag_list)
validation_data= df_entity_spans.values.tolist()

# Get & Persist DocBin to disk
doc_bin_test= get_doc_bin(validation_data,nlp)
doc_bin_test.to_disk("test.spacy")
##########################################

"""Running the python instruction to train the model"""

!python -m spacy train config.cfg --paths.train train.spacy --paths.dev test.spacy --output models --training.eval_frequency 50 --training.max_steps 1100